import numpy as np
from scipy.signal import correlate
from scipy.optimize import curve_fit
from scipy.signal import savgol_filter
from scipy.ndimage import convolve, gaussian_filter1d
from skimage.morphology import skeletonize, label, binary_dilation
import matplotlib.pyplot as plt
import matplotlib.patches as patches


class DelayGraph:
    """Class involving methods to generate delaygraph from freq-time image. DelayGraph is generated by calculating the lags with the mean signal with each of the freq channel signals"""

    def __init__(self, normalize_delays: bool = True, do_smoothing: bool = True):
        self._normalize_delays = normalize_delays
        self._do_smoothing = do_smoothing

    def __call__(self, dispersed_freq_time: np.ndarray):
        x_lags, y_pos = DelayGraph.protocol(dispersed_freq_time=dispersed_freq_time)
        if self._normalize_delays:
            max_lag = dispersed_freq_time.shape[1]
            x_lags = x_lags / max_lag

        if self._do_smoothing:
            x_lags = gaussian_filter1d(x_lags, 2)

        return x_lags, y_pos

    def __repr__(self) -> str:
        return f"DelayGraph object with attributes {self.__dict__}"

    def plot(self, dispersed_freq_time: np.ndarray):
        """plot the delay graph generated from dispersed freq-time image

        Args:
            dispersed_freq_time (np.ndarray): dispersed pulsar freq-time image
        """
        x_lags, y_pos = self.__call__(dispersed_freq_time=dispersed_freq_time)
        fig1, ax = plt.subplots(1, 1, figsize=(3.5, 3.5))
        ax.plot(x_lags, (y_pos))
        ax.set_xlabel("lags (a.u)")
        if self._normalize_delays:
            ax.set_xlim(left=0, right=1)
        else:
            ax.set_xlim(left=0, right=dispersed_freq_time.shape[1])
        ax.set_ylim(bottom=0, top=dispersed_freq_time.shape[0])
        ax.set_ylabel("freq channel")
        ax.grid("True")
        ax.invert_yaxis()
        ax.set_aspect("auto")

    @staticmethod
    def protocol(dispersed_freq_time: np.ndarray):
        """Method to generate the dispersed signal

        Args:
            dispersed_freq_time (np.ndarray): dispersed pulsar freq-time image

        Returns:
            (1D np.ndarray,1D np.ndarray): delaygraph signal as lags and freq-channel index
        """
        dispersed_freq_time = dispersed_freq_time - np.min(
            dispersed_freq_time.flatten()
        )
        if np.max(dispersed_freq_time.flatten()) > 0:
            dispersed_freq_time = dispersed_freq_time / np.max(
                dispersed_freq_time.flatten()
            )
        ref_signal = np.sum(dispersed_freq_time, axis=0)
        num_freq_channels = dispersed_freq_time.shape[0]
        lags = np.arange(0, len(ref_signal))
        x_lags = np.zeros(num_freq_channels)
        y_pos = np.arange(0, num_freq_channels)
        for freq_channel in range(num_freq_channels):
            current_signal = dispersed_freq_time[freq_channel, :]
            cross_corr = correlate(current_signal, ref_signal, mode="same")
            if np.sum(current_signal) > 0:
                mean_lag = np.sum(cross_corr * lags) / np.sum(cross_corr)
            else:
                # mean_lag = len(ref_signal)/2
                mean_lag = 0.5 * len(ref_signal)
            # print(np.argmax(cross_corr))
            # x_lags[freq_channel] = lags[np.argmax(cross_corr)]
            x_lags[freq_channel] = mean_lag

        return x_lags, y_pos


class LineClassifier:
    """Class to classify delaygraphs into pulse or not pulse after fitting a line to delaygraph"""

    def __init__(
        self,
        no_pulsar_slope_range: tuple = None,
    ):
        self.no_pulse_slope_range = no_pulsar_slope_range

    def __call__(
        self, x_lags_normalized: np.ndarray, y_channels_normalized: np.ndarray
    ):
        theta_slope, line_func, popt = LineClassifier.protocol(
            x_lags_normalized=x_lags_normalized,
            y_channels_normalized=y_channels_normalized,
        )
        if (
            theta_slope > self.no_pulse_slope_range[0]
            and theta_slope <= self.no_pulse_slope_range[1]
        ):
            pulsar_present = False
        else:
            pulsar_present = True
        return pulsar_present

    def protocol(x_lags_normalized: np.ndarray, y_channels_normalized: np.ndarray):
        """method to classify delaygraphs by fitting line

        Args:
            x_lags_normalized (np.ndarray): lags from delay graph
            y_channels_normalized (np.ndarray): freq channel index

        Returns:
            (float,func,list): slope of the fitted line, function handle used for fitting, fitted params
        """
        x_coors, y_coors = LineClassifier.normalize_coors(
            x_coors=x_lags_normalized, y_coors=y_channels_normalized
        )
        x_coors, y_coors = LineClassifier.correct_for_nans(
            x_coors=x_coors, y_coors=y_coors
        )
        x_coors, y_coors = LineClassifier.smooth_curve(x_coors=x_coors, y_coors=y_coors)
        theta_slope, line_func, popt = LineClassifier.fit_line_curve(
            x_coors=x_coors, y_coors=y_coors
        )
        if theta_slope < 0:
            theta_slope = 180 + theta_slope
        theta_slope = 180 - theta_slope
        return theta_slope, line_func, popt

    @staticmethod
    def normalize_coors(x_coors: np.ndarray, y_coors: np.ndarray):
        """Normalize lags from 0 to 1

        Args:
            x_coors (np.ndarray): lags from delay graph
            y_coors (np.ndarray): freq channel index

        Returns:
            (np.ndarray,np.ndarray): normalized lags and freq index
        """
        x_coors = x_coors / max(x_coors)
        y_coors = y_coors / max(y_coors)
        return x_coors, y_coors

    @staticmethod
    def correct_for_nans(x_coors: np.ndarray, y_coors: np.ndarray):
        """Replace nans with 0.5

        Args:
            x_coors (np.ndarray): lags from delay graph
            y_coors (np.ndarray): freq channel index

        Returns:
           (np.ndarray,np.ndarray): corrected lags and freq index
        """
        x_coors = np.array([x if np.isfinite(x) else 0.5 for x in x_coors])
        return x_coors, y_coors

    @staticmethod
    def smooth_curve(
        x_coors: np.ndarray,
        y_coors: np.ndarray,
        window_size: int = 6,
        polynomial_order: int = 4,
    ):
        """smooth lags

        Args:
            x_coors (np.ndarray): lags from delay graph
            y_coors (np.ndarray): freq channel index
            window_size (int, optional): smoothing savgol filter size. Defaults to 6.
            polynomial_order (int, optional): polynomial order savgol filter size. Defaults to 4.

        Returns:
            (np.ndarray,np.ndarray): smoothed lags and freq index
        """
        x_coors = savgol_filter(x_coors, window_size, polynomial_order)
        return x_coors, y_coors

    @staticmethod
    def fit_line_curve(
        x_coors: np.ndarray,
        y_coors: np.ndarray,
    ):
        """Fit line curve

        Args:
            x_coors (np.ndarray): lags from delay graph
            y_coors (np.ndarray): freq channel index

        Returns:
            (float,func,list): slope of the fitted line, function handle used for fitting, fitted params
        """
        line_func = lambda x, m, c: m * x + c
        popt, pcov = curve_fit(
            line_func,
            y_coors,
            x_coors,
            maxfev=5000,
            bounds=([-np.inf, -1], [np.inf, 1]),
        )
        m_fitted = popt[0]
        return np.arctan(1 / m_fitted) * 180 / np.pi, line_func, popt

    def __repr__(self):
        pass

    def plot(self, x_lags_normalized: np.ndarray, y_channels_normalized: np.ndarray):
        """plot the fitted line with the data

        Args:
            x_lags_normalized (np.ndarray): normalized lags from delay graph
            y_channels_normalized (np.ndarray): freq channel index
        """
        if max(x_lags_normalized) > 1:
            x_lags_normalized = x_lags_normalized / max(x_lags_normalized)
        if max(y_channels_normalized) > 1:
            y_channels_normalized = y_channels_normalized / max(y_channels_normalized)
        theta_slope, line_func, popt = LineClassifier.protocol(
            x_lags_normalized=x_lags_normalized,
            y_channels_normalized=y_channels_normalized,
        )
        x_lags = x_lags_normalized
        y_pos = y_channels_normalized
        x_fitted = line_func(y_pos, popt[0], 0.5)
        fig1, ax = plt.subplots(1, 1, figsize=(5, 5))
        ax.plot(x_lags, (y_pos))
        ax.plot(x_fitted, y_pos)
        ax.set_xlabel("lags (a.u)")
        ax.set_xlim(left=0, right=1)
        ax.set_ylim(bottom=0, top=1)
        ax.set_ylabel("freq channel")
        ax.grid("True")
        ax.invert_yaxis()
        ax.set_aspect("auto")


class ConnectedComponents:
    """Class to calculate connected components (CC) from segmented freq-time image to label signal types"""

    def __init__(self, dilate: bool = True, small_component_size: int = 10):
        self.dilate = dilate
        self.small_component_size = small_component_size

    def __call__(self, dispersed_freq_time_segmented: np.ndarray):
        return self.protocol(
            dispersed_freq_time_segmented=dispersed_freq_time_segmented
        )

    def __repr__(self) -> str:
        return f"ConnectedComponents with props {self.__dict__}"

    def protocol(self, dispersed_freq_time_segmented: np.ndarray):
        """Method to perform CC analysis

        Args:
            dispersed_freq_time_segmented (np.ndarray): binary mask of dispersed freq-time image

        Returns:
            np.ndarray: labelled skeleton image each label representing a connected component
        """
        skeleton_img = ConnectedComponents.skeletonize_image(
            dispersed_freq_time_segmented=dispersed_freq_time_segmented
        )
        node_pixels = ConnectedComponents.detect_nodes_in_skeleton(
            skeleton_img=skeleton_img, dilate=self.dilate
        )
        skeleton_img_no_nodes = ConnectedComponents.divide_branches_in_skeleton(
            skeleton_img=skeleton_img, node_pixels=node_pixels
        )
        labelled_skeleton = ConnectedComponents.label_skeleton(
            skeleton_img=skeleton_img_no_nodes
        )
        filtered_labelled_skeleton = ConnectedComponents.filter_out_small_components(
            labelled_skeleton_img=labelled_skeleton,
            small_component_size=self.small_component_size,
        )
        return filtered_labelled_skeleton

    @staticmethod
    def skeletonize_image(dispersed_freq_time_segmented: np.ndarray):
        """Skeletonize components of a binary image

        Args:
            dispersed_freq_time_segmented (np.ndarray): binary mask of dispersed freq-time image

        Returns:
            (np.ndarray): skeletonized image
        """
        skeleton_img = skeletonize(image=dispersed_freq_time_segmented)
        # skeleton_img_labelled = label(label_image=skeleton_img ,connectivity=2)
        return skeleton_img

    @staticmethod
    def detect_nodes_in_skeleton(skeleton_img: np.ndarray, dilate: bool = False):
        """Method to put detect dots in regions where line elements from skeletonized image criss cross

        Args:
            skeleton_img (np.ndarray): skeletonized binary dispersed freq-time image
            dilate (bool, optional): option to dilate the connected components after putting the dots. Defaults to False.

        Returns:
            (np.ndarray): boolean numpy 2d array with value True in place of dots
        """
        kernel = np.array([[1, 1, 1], [1, 0, 1], [1, 1, 1]])
        neighbors_count = convolve(
            skeleton_img.astype(int), kernel, mode="constant", cval=0
        )
        node_pixels = np.logical_and(neighbors_count >= 3, skeleton_img == 1)
        if dilate:
            node_pixels = binary_dilation(image=node_pixels)
        return node_pixels

    @staticmethod
    def divide_branches_in_skeleton(skeleton_img: np.ndarray, node_pixels: np.ndarray):
        """Cut lines in skeleton where they criss cross

        Args:
            skeleton_img (np.ndarray): skeletonized binary dispersed freq-time image
            node_pixels (np.ndarray): boolean numpy 2d array with value True in place of dots

        Returns:
            (np.ndarray): skeletonized image with the lines or curves without any criss cross
        """
        # not_node_image = np.logical_not(node_pixels)
        node_pixels.astype(int)
        skeleton_img_no_nodes = skeleton_img
        skeleton_img_no_nodes.astype(int)
        skeleton_img_no_nodes[node_pixels == 1] = 0
        return skeleton_img_no_nodes

    @staticmethod
    def label_skeleton(skeleton_img: np.ndarray):
        """label the skeleton with each label id representing each connected component

        Args:
            skeleton_img (np.ndarray): skeletonized binary dispersed freq-time image

        Returns:
            np.ndarray: labelled skeleton image each label representing a connected component
        """
        labelled_skeleton = label(label_image=skeleton_img)
        return labelled_skeleton

    @staticmethod
    def filter_out_small_components(
        labelled_skeleton_img: np.ndarray, small_component_size: int = 10
    ):
        """Filter CC based on number of pixels

        Args:
            labelled_skeleton_img (np.ndarray): labelled  image each label representing a connected component
            small_component_size (int, optional): minimum CC size threshold. Defaults to 10.

        Returns:
            np.ndarray: filtered labelled image
        """
        tot_num_components = np.max(labelled_skeleton_img.flatten())
        label_ids = np.arange(1, tot_num_components + 1)
        is_it_small = [
            sum(((labelled_skeleton_img == label_id).astype(int)).flatten())
            <= small_component_size
            for label_id in label_ids
        ]
        small_labels = label_ids[is_it_small]
        small_index_mat_logical_noter = np.isin(labelled_skeleton_img, small_labels)
        labelled_skeleton_img[small_index_mat_logical_noter] = 0
        return labelled_skeleton_img

    def plot(self, dispersed_freq_time_segmented: np.ndarray):
        """plots the results of the CC analysis

        Args:
            dispersed_freq_time_segmented (np.ndarray): binary mask of dispersed freq-time image
        """
        fig1, ax = plt.subplots(1, 2, figsize=(10, 5))
        # dist_output = ConnectedComponents.skeletonize_image(dispersed_freq_time_segmented=dispersed_freq_time_segmented)
        ax[0].imshow(dispersed_freq_time_segmented)
        ax[0].set_xlabel("phase")
        ax[0].set_ylabel("freq channel")
        ax[0].grid("True")
        ax[0].set_aspect("auto")
        labelled_skeleton = self.__call__(
            dispersed_freq_time_segmented=dispersed_freq_time_segmented
        )
        ax[1].imshow(labelled_skeleton)
        ax[1].set_xlabel("phase")
        ax[1].set_ylabel("freq channel")
        ax[1].grid("True")
        ax[1].set_aspect("auto")


class FitSegmentedTraces:
    """Class to give a cattegory to connected components in a skeleton image by fitting a line"""

    def __init__(self, labelled_skeleton: np.ndarray):
        self.labelled_skeleton = labelled_skeleton

    def __call__(self, label_id: int):
        result = self.protocol(label_id=label_id)
        return result

    def __repr__(self) -> str:
        pass

    def protocol(self, label_id: int):
        """_summary_

        Args:
            label_id (int): _description_

        Returns:
            (np.ndarray,np.ndarray,list,function,str,int): returns coordinates of the label skeleton,fitted params, fitted function, category detected, number of points
        """
        x_coors_sorted, y_coors_sorted = FitSegmentedTraces.extract_coors(
            labelled_skeleton=self.labelled_skeleton, label_id=label_id
        )
        popt, func = FitSegmentedTraces.fit_linear_curve(
            x_coors_sorted=x_coors_sorted, y_coors_sorted=y_coors_sorted
        )
        category = FitSegmentedTraces.categorize_trace(m=popt[0])
        num_points = len(x_coors_sorted)
        return x_coors_sorted, y_coors_sorted, popt, func, category, num_points

    @staticmethod
    def extract_coors(labelled_skeleton: np.ndarray, label_id: int):
        """Extract coors of a label

        Args:
            labelled_skeleton (np.ndarray): labelled skeleton image
            label_id (int): _description_

        Returns:
            (np.ndarray,np.ndarray): returns coordinates of the label skeleton
        """
        x_coors = np.array([np.arange(0, labelled_skeleton.shape[1])])
        x_coor_mat = np.matmul(x_coors.T, np.ones((1, labelled_skeleton.shape[0]))).T

        y_coors = np.array([np.arange(0, labelled_skeleton.shape[0])])
        y_coor_mat = np.matmul(y_coors.T, np.ones((1, labelled_skeleton.shape[1])))

        x_coors = (x_coor_mat[labelled_skeleton == label_id]).flatten()
        y_coors = (y_coor_mat[labelled_skeleton == label_id]).flatten()

        sorted_index_x = np.argsort(x_coors)
        x_coors_sorted = x_coors[sorted_index_x]
        y_coors_sorted = y_coors[sorted_index_x]

        return x_coors_sorted, y_coors_sorted

    @staticmethod
    def categorize_trace(m: float):
        """Method to categorize based on slope of the fitted line

        Args:
            m (float): slope

        Returns:
            str: category
        """
        dy_dx = m
        theta_degree = np.arctan(m) * 180 / np.pi
        if theta_degree < 0:
            theta_degree = theta_degree + 180
        # print(theta_degree)
        if theta_degree < 85 and theta_degree > 5:
            category = "Pulsar"
        elif theta_degree < 100 and theta_degree > 85:
            category = "Noise (BBRFI)"

        elif (theta_degree) < 5 or (180 - theta_degree) < 5:
            category = "Noise (NBRFI)"

        else:
            category = "Noise (None)"
        # print(theta_degree,category)
        return category

    @staticmethod
    def fit_linear_curve(x_coors_sorted, y_coors_sorted):
        """Method to fit a line curve to the coors of the skeleton label

        Args:
            x_coors_sorted (_type_): x coordinates of the label skeleton
            y_coors_sorted (_type_): y coordinates of the label skeleton

        Returns:
            (list,function): fitted parameter,fitted function
        """
        func = FitSegmentedTraces._fit_linear_func
        popt, pcov = curve_fit(func, x_coors_sorted, y_coors_sorted, maxfev=5000)
        return popt, func

    @staticmethod
    def _fit_linear_func(x, m, c):
        return m * x + c

    def plot(self, label_id: int):
        """plot results specific to a label

        Args:
            label_id (int): label value representing a cc in the skeleton image
        """
        result = self.__call__(label_id=label_id)
        x_coors_sorted = result[0]
        y_coors_sorted = result[1]
        func = result[3]
        popt = result[2]
        fig1, ax = plt.subplots(1, 1, figsize=(5, 5))
        ax.plot(x_coors_sorted, y_coors_sorted)
        fitted_y_coors = np.array([func(x, *popt) for x in x_coors_sorted])
        ax.plot(x_coors_sorted, fitted_y_coors)
        ax.set_xlabel("lags (a.u)")
        ax.set_xlim(left=0, right=self.labelled_skeleton.shape[1])
        ax.set_ylim(bottom=0, top=self.labelled_skeleton.shape[0])
        # ax.set_label(f'fitted a(x-b)**2 + c (a,b,c) = {(popt)}')
        ax.set_title(f"fitted m*x + c (m,c) = {popt[0]:.2f},\n{popt[1]:.2f}")
        ax.set_ylabel("freq channel")
        ax.grid("True")
        ax.invert_yaxis()
        ax.set_aspect("auto")

    @classmethod
    def fitt_to_all_traces(cls, labelled_skeleton: np.ndarray):
        """Method to categorize all labels

        Args:
            labelled_skeleton (np.ndarray): labelled skeleton

        Returns:
            list: results specific to each label in a list
        """
        fit_engine = cls(labelled_skeleton=labelled_skeleton)
        labels = np.unique(labelled_skeleton.flatten())
        labels = [x for x in labels if x > 0]
        if labels:
            results = [fit_engine(x) for x in labels]
        else:
            results = []

        return results

    @classmethod
    def plot_all_traces(cls, labelled_skeleton: np.ndarray):
        """Plot results from all labels

        Args:
            labelled_skeleton (np.ndarray): labelled skeleton
        """
        results = cls.fitt_to_all_traces(labelled_skeleton=labelled_skeleton)
        # fig1, ax = plt.subplots(1, 1, figsize=(5, 5))
        if results:
            fig1, ax = plt.subplots(1, 1, figsize=(5, 5))
            for result in results:
                x_coors_sorted = result[0]
                y_coors_sorted = result[1]
                func = result[3]
                popt = result[2]
                ax.plot(x_coors_sorted, y_coors_sorted, "*b")
                fitted_y_coors = np.array([func(x, *popt) for x in x_coors_sorted])
                ax.plot(x_coors_sorted, fitted_y_coors, "-r")
            ax.set_xlabel("lags (a.u)")
            ax.set_xlim(left=0, right=labelled_skeleton.shape[1])
            ax.set_ylim(bottom=0, top=labelled_skeleton.shape[0])
            ax.set_ylabel("freq channel")
            ax.grid("True")
            ax.invert_yaxis()
            ax.set_aspect("auto")

    @classmethod
    def return_detected_categories(
        cls, labelled_skeleton: np.ndarray, return_detailed_results: bool = False
    ):
        """Method that summarizes the results into a dict of categories with values of each keys representing the mean length of the categories

        Args:
            labelled_skeleton (np.ndarray): labelled skeleton
            return_detailed_results (bool, optional): if true returns the results in list of each labels . Defaults to False.

        Returns:
            list: results in list of each labels
        """
        results = cls.fitt_to_all_traces(labelled_skeleton=labelled_skeleton)
        category_dict = {
            "Pulsar": [],
            "Noise (NBRFI)": [],
            "Noise (BBRFI)": [],
            "Noise (None)": [],
        }
        categories_in_results = [x[4] for x in results]
        categories_len = [x[5] for x in results]
        [
            category_dict[x].append(y)
            for x, y in zip(categories_in_results, categories_len)
        ]
        category_mean_lengths = [
            np.mean(category_dict[x]) if np.array(category_dict[x]).any() else 0
            for x in category_dict.keys()
        ]
        [
            category_dict.update({x: y})
            for x, y in zip(category_dict.keys(), category_mean_lengths)
        ]
        if return_detailed_results:
            # print('debug detailed res')
            return results
        else:
            return category_dict

    @classmethod
    def plot_all_traces_with_categories(
        cls, labelled_skeleton: np.ndarray, image: np.ndarray = None
    ):
        """Plots detailed result of each labels

        Args:
            labelled_skeleton (np.ndarray): labelled_skeleton
            image (np.ndarray, optional): image to superimpose the results. Defaults to None.
        """
        results = cls.fitt_to_all_traces(labelled_skeleton=labelled_skeleton)
        # fig1, ax = plt.subplots(1, 1, figsize=(5, 5))
        if results:
            fig1, ax = plt.subplots(1, 1, figsize=(5, 5))
            if image != None:
                ax.imshow(image)
            for result in results:
                x_coors_sorted = result[0]
                y_coors_sorted = result[1]
                func = result[3]
                popt = result[2]
                category = result[4]
                num_points = result[5]
                start_rect = (np.min(x_coors_sorted), np.min(y_coors_sorted))
                min_rect_dim = 10
                height = [
                    (
                        np.max(y_coors_sorted) - np.min(y_coors_sorted)
                        if np.max(y_coors_sorted) - np.min(y_coors_sorted)
                        > min_rect_dim
                        else min_rect_dim
                    )
                    for _ in range(1)
                ]
                width = [
                    (
                        np.max(x_coors_sorted) - np.min(x_coors_sorted)
                        if np.max(x_coors_sorted) - np.min(x_coors_sorted)
                        > min_rect_dim
                        else min_rect_dim
                    )
                    for _ in range(1)
                ]
                if category == "Pulsar":
                    color = "r"
                    # rect = patches.Rectangle(start_rect, width[0] , height[0] , linewidth=1, edgecolor='r', facecolor='none')
                else:
                    color = "b"
                    # rect = patches.Rectangle(start_rect, width[0] , height[0] , linewidth=1, edgecolor='g', facecolor='none')
                rect = patches.Rectangle(
                    start_rect,
                    width[0],
                    height[0],
                    linewidth=1,
                    edgecolor=color,
                    facecolor="none",
                    label=f"{category}{num_points}",
                )
                ax.plot(x_coors_sorted, y_coors_sorted, ".g")
                fitted_y_coors = np.array([func(x, *popt) for x in x_coors_sorted])
                ax.plot(x_coors_sorted, fitted_y_coors, color)
                ax.add_patch(rect)
                ax.annotate(
                    f"{category}{num_points}", start_rect, fontsize=10, color=color
                )
            ax.set_xlabel("lags (a.u)")
            ax.set_xlim(left=0, right=labelled_skeleton.shape[1])
            ax.set_ylim(bottom=0, top=labelled_skeleton.shape[0])
            ax.set_ylabel("freq channel")
            ax.grid("True")
            ax.invert_yaxis()
            ax.set_aspect("auto")
